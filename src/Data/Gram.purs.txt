module Data.Gram where

import Data.Either
import Data.Either.Nested
import Prelude

import Data.Array as Array
import Data.Bifunctor (bimap, lmap, rmap)
import Data.Const (Const(..))
import Data.Enum (enumFromTo)
import Data.Eq (class Eq1, eq1)
import Data.Foldable (class Foldable, foldMap, foldl, foldr, intercalate, sequence_)
import Data.Foldable as Foldable
import Data.Generic.Rep (class Generic)
import Data.Identity (Identity(..))
import Data.List (List(..), (:))
import Data.List as List
import Data.List.Rev as RevList
import Data.List.Zip as ZipList
import Data.Maybe (Maybe(..), fromMaybe')
import Data.Newtype (class Newtype)
import Data.Newtype as Newtype
import Data.Ord (class Ord1, compare1)
import Data.Traversable (class Traversable, sequence, sequenceDefault, traverse)
import Data.Tuple (Tuple(..), fst, snd)
import Data.Tuple.Nested (type (/\), (/\))
import Data.Unify (Meta(..))
import Debug as Debug
import Effect (Effect)
import Effect.Class.Console (log)
import Partial.Unsafe (unsafeCrashWith)
import Text.Pretty (braces, braces2, parens, pretty, quotes)
import Type.Direction as Dir
import Utility (assert)

class (Eq l, Show l) <= GramExprLabel l where
  prettyNodeG' :: NodeG Array l String -> Maybe String
  expectedKidsCount :: l -> Int

-- assert that `expectedKidsCount` matches the actual kids count
assertWellformedNodeG :: forall l kid. GramExprLabel l => NodeG Array l kid -> String -> Unit
assertWellformedNodeG (l /\ kids) tag = do
  assert (Array.length kids == expectedKidsCount l) ("[" <> tag <> "] A gram node with ExprLabel " <> quotes (show l) <> " is expected to have " <> show (expectedKidsCount l) <> " kids, but an instance of it actually has " <> show (Foldable.length kids :: Int) <> " kids.") \_ -> unit

assertWellformedExpr (Gram node) = assertWellformedNodeG node

unsafeCrashWithUnexpectedMalformedNodeG :: forall l kid a. GramExprLabel l => Show kid => NodeG Array l kid -> String -> a
unsafeCrashWithUnexpectedMalformedNodeG node tag = unsafeCrashWith $ "[" <> tag <> "] Even though `assertWellformedNodeG` passed, still found malformed `NodeG`: " <> show node

unsafeCrashWithUnexpectedMalformedExpr (Gram node) = unsafeCrashWithUnexpectedMalformedNodeG node

-- checks `expectedKidsCount` before printing
prettyNodeG :: forall l. GramExprLabel l => NodeG Array l String -> String
prettyNodeG node = do
  let _ = assertWellformedNodeG node "prettyNodeG"
  fromMaybe' (\_ -> unsafeCrashWithUnexpectedMalformedNodeG node "prettyNodeG")
      $ prettyNodeG' node

instance GramExprLabel l => GramExprLabel (Meta l) where
  prettyNodeG' ((Meta (Left x)) /\ _kids) = pure $ pretty x
  prettyNodeG' ((Meta (Right l)) /\ kids) = pure $ prettyNodeG (l /\ kids)

  expectedKidsCount (Meta (Left _)) = 0
  expectedKidsCount (Meta (Right l)) = expectedKidsCount l

instance GramExprLabel l => GramExprLabel (ChangeLabel l) where
  prettyNodeG' (Plus th /\ kids) = pure $ prettyTooth th (intercalate "" kids)
  prettyNodeG' (Minus th /\ kids) = pure $ prettyTooth th (intercalate "" kids)
  prettyNodeG' (Expr l /\ kids) = pure $ prettyNodeG (l /\ kids)

  prettyNodeG' (Replace e1 e2 /\ _) = pure $ parens (prettyExpr e1 <> " ~~> " <> prettyExpr e2)

  expectedKidsCount (Plus _) = 1
  expectedKidsCount (Minus _) = 1
  expectedKidsCount (Expr l) = expectedKidsCount l
  expectedKidsCount (Replace _ _) = 0

prettyExpr :: forall l. GramExprLabel l => Expr l -> String
prettyExpr (Gram (l /\ kids)) = prettyNodeG (l /\ (prettyExpr <$> kids))

prettyTooth :: forall l. GramExprLabel l => Tooth l -> String -> String
prettyTooth (l /\ zip) innerStr = prettyNodeG (l /\ Array.fromFoldable (ZipList.unpathAround innerStr (prettyExpr <$> zip)))

-- prettyPath1Up :: forall l. GramExprLabel l => Path1 l -> String -> String
-- prettyPath1Up (Gram (th /\ Nothing)) innerStr = prettyTooth th innerStr
-- prettyPath1Up (Gram (th /\ (Just path))) innerStr = prettyPath1Up path $ prettyTooth th innerStr

prettyPathUp :: forall l. GramExprLabel l => Path Dir.Up l -> String -> String
-- prettyPathUp (Path Nothing) innerStr = innerStr
-- prettyPathUp (Path (Just path1)) innerStr = ?a -- prettyPath1Up path1 innerStr
-- !TODO use generic traverse path
prettyPathUp = ?a

-- prettyPath1Down :: forall l. GramExprLabel l => Path1 l -> String -> String
-- prettyPath1Down (Gram (th /\ Nothing)) innerStr = prettyTooth th innerStr
-- prettyPath1Down (Gram (th /\ Just path)) innerStr = prettyTooth th (prettyPath1Down path innerStr)

prettyPathDown :: forall l. GramExprLabel l => Path Dir.Down l -> String -> String
prettyPathDown (Path Nothing) innerStr = innerStr
-- !TODO use generic traverse path
prettyPathDown (Path (Just path1)) innerStr = ?a -- prettyPath1Down path1 innerStr

prettyZipper :: forall l. GramExprLabel l => Zipper l -> String
prettyZipper zipper = prettyPathUp zipper.path (braces2 (prettyExpr zipper.expr))

-- | A `Gram` is a generalization of a tree (and a specialization of a
-- | fixpoint), where each node of the `Gram` has a ExprLabel of type `l`, and the kids are 
data Gram j l = Gram (NodeG j l (Gram j l))

derive instance Generic (Gram j l) _
derive instance Functor j => Functor (Gram j)
instance (Eq1 j, Eq l) => Eq (Gram j l) where 
  eq (Gram (l1 /\ j1)) (Gram (l2 /\ j2)) = l1 == l2 && eq1 j1 j2
instance (Ord1 j, Ord l) => Ord (Gram j l) where
  compare (Gram (l1 /\ j1)) (Gram (l2 /\ j2)) =
    case compare l1 l2 of
      EQ -> compare1 j1 j2
      ord -> ord
instance Eq1 j => Eq1 (Gram j) where
  eq1 (Gram (l1 /\ j1)) (Gram (l2 /\ j2)) = l1 == l2 && eq1 j1 j2
instance Ord1 j => Ord1 (Gram j) where
  compare1 (Gram (l1 /\ j1)) (Gram (l2 /\ j2)) =
    case compare l1 l2 of
      EQ -> compare1 j1 j2
      ord -> ord

instance Foldable j => Foldable (Gram j) where
  foldMap f (Gram (l /\ j)) = f l <> foldMap (foldMap f) j
  foldr f b (Gram (l /\ j)) = foldr (\g  b' -> foldr f b' g) (f l b) j
  foldl f b (Gram (l /\ j)) = foldl (\b' g  -> foldl f b' g) (f b l) j

instance (Functor j, Traversable j) => Traversable (Gram j) where
  traverse f (Gram (l /\ j)) = Gram <$> (Tuple <$> f l <*> traverse (traverse f) j)
  sequence fa = sequenceDefault fa

instance (Show l, Functor j, Foldable j) => Show (Gram j l) where
  show = foldMapGram \(l /\ j) ->
    if Foldable.null j 
      then show l
      else "(" <> show l <> " " <> intercalate " " j <> ")"

-- | In order to show any `Gram`, first map each ExprLabel to `unit`, and then show.
-- | This will only show the structure of the `Gram` and nothing about the
-- | ExprLabels -- useful for debug in the generic code. (Alternatively, could
-- | include `Show l` typeclass constraint everywhere, but that's annoying).
showGramStructure :: forall j l. Functor j => Foldable j => Gram j l -> String
showGramStructure = foldMapGram \(_ /\ j) -> "(" <> intercalate " " j <> ")"

{-
class IsMeta meta concrete | meta -> concrete where
  fromMetaVar :: MetaVar -> meta
  fromConcrete :: concrete -> meta
  matchMeta :: forall a. meta -> {meta :: MetaVar -> a, concrete :: concrete -> a} -> a

instance IsMeta (Meta l) l where
  fromMetaVar = Meta <<< Left
  fromConcrete = Meta <<< Right
  matchMeta (Meta (Left mv)) f = f.meta mv
  matchMeta (Meta (Right l)) f = f.concrete l

instance (IsMeta ml l, Foldable j, Plus.Plus j) => IsMeta (Gram j ml) (Node j l ml) where
  fromMetaVar mv = Gram (fromMetaVar mv /\ empty)
  fromConcrete (l /\ j) = Gram (fromConcrete l /\ j)
  matchMeta (Gram (ml /\ j)) f = matchMeta ml
    { meta: \mv -> 
        if Foldable.null j 
          then f.meta mv
          else unsafeThrow "metavariable case of Gram should not have any kids"
    , concrete: \l -> f.concrete (l /\ j)
    }

newtype UnifyT meta m a = UnifyT (UnifyT' meta m a)
type UnifyT' meta m a = StateT (UnifySt meta m) (MaybeT m) a
type UnifySt meta m = Map.Map MetaVar (UnifyT meta m meta)

runUnifyT (UnifyT m) = m

instance MonadTrans (UnifyT meta) where lift = UnifyT <<< lift <<< lift
instance Functor m => Functor (UnifyT meta m) where map f (UnifyT ma) = UnifyT (f <$> ma)
instance Monad m => Apply (UnifyT meta m) where apply (UnifyT mf) (UnifyT ma) = UnifyT (mf <*> ma)
instance Monad m => Bind (UnifyT meta m) where bind (UnifyT ma) k = UnifyT (ma >>= k >>> runUnifyT)
instance Monad m => Applicative (UnifyT meta m) where pure a = UnifyT (pure a)

-- ml is meta ExprLabel
-- cl is concrete ExprLabel
instance (Monad m, IsMeta ml l, Eq l, Foldable j, Unfoldable j, Traversable j, Plus.Plus j) => Unify (UnifyT (Gram j ml) m) (UnifyT (Gram j ml) m (Gram j ml)) where
  unify m_g1 m_g2 = do
    m_g1 >>= \g1 -> matchMeta g1 
      { meta: \mv1 -> do
          UnifyT $ modify_ $ Map.insert mv1 $ m_g2
          pure m_g2
      , concrete: \(l1 /\ j1) -> m_g2 >>= \g2 -> matchMeta g2 
        { meta: \mv2 -> do
            UnifyT $ modify_ $ Map.insert mv2 $ m_g1
            pure m_g1
        , concrete: \(l2 /\ j2) -> do
            -- equate ExprLabels
            unless (l1 == l2) do UnifyT empty
            -- unify kids
            j' <- 
              (Array.toUnfoldable :: Array _ -> j _) <$>
              flip traverse (Array.zip (Array.fromFoldable j1) (Array.fromFoldable j2)) \(g1' /\ g2') -> do
                unify 
                  (substUnifyM g1' :: UnifyT (Gram j ml) m (Gram j ml)) 
                  (substUnifyM g2' :: UnifyT (Gram j ml) m (Gram j ml))

            substUnifyM <<< Gram <<< (fromConcrete l1 /\ _) <$> sequence j'
        }
      }
      where
      substUnifyM :: Gram j ml -> UnifyT (Gram j ml) m (Gram j ml)
      substUnifyM g = matchMeta g
        { meta: \mv -> UnifyT (gets (Map.lookup mv)) >>= maybe (pure g) identity
        , concrete: \(l /\ j) -> fromConcrete <<< (l /\ _) <$> substUnifyM `traverse` j
        }
-}

-- | `Node` of `Gram` parametrized by type of kids.
type NodeG :: forall k. (k -> Type) -> Type -> k -> Type
type NodeG j l g = l /\ j g

-- | Alias for `NodeG` with `Gram j l'` kids.
type Node j l l' = NodeG j l (Gram j l')
-- | Alias for `NodeG` with `m (Gram j l')` kids.
type NodeM j m l l' = NodeG j l (m (Gram j l'))

type NodeMG :: forall k1 k2. (k1 -> Type) -> (k2 -> k1) -> Type -> k2 -> Type
type NodeMG j m l g = NodeG j l (m g)

showNodeUnit :: forall j l g. Functor j => Foldable j => NodeG j l g -> String
showNodeUnit (_l /\ j) = "(" <> show unit <> " /\\ " <> "[" <> intercalate ", " (show <<< const unit <$> j) <> "]" <> ")"

mapNodeG_g :: forall j l g g'. Functor j => (g -> g') -> NodeG j l g -> NodeG j l g'
mapNodeG_g f = rmap (map f)

mapNodeG_l :: forall j l l' g. Functor j => (l -> l') -> NodeG j l g -> NodeG j l' g
mapNodeG_l f = lmap f

bimapNodeG :: forall j l l' g g'. Functor j => (l -> l') -> (g -> g') -> NodeG j l g -> NodeG j l' g'
bimapNodeG f_l f_g = bimap f_l (map f_g)

unwrapGram (Gram g) = g
overGram f = unwrapGram >>> f >>> Gram
overMGram k = unwrapGram >>> k >>> map Gram
gramExprLabel = unwrapGram >>> fst
gramJoint = unwrapGram >>> snd

{-
-- !TODO OLD

-- | Map a function `f` over the ExprLabels in a `Gram`, taking into account `Node`
-- | structure. This is implemented by `travereGram`ing via the trivial
-- | applicative `Identity`.
-- |
-- | This should actually just serve as a spec, since `Gram` is automatically
-- | derived to be a functor.
mapGram :: forall j l l'. Functor j => (Node j l l' -> Node j l' l') -> Gram j l -> Gram j l'
mapGram f = Newtype.unwrap <<< traverseGram (Identity <<< f <<< mapNodeG_g Newtype.unwrap)

-- | Fold-map a function `f` over `Gram` taking into account `Node` structure.
-- | This is implemented by `traverseGram`ing via the applicative `Const m`,
-- | where `m` is the monoid we are fold-mapping into, which just accumulates
-- | the monoid value and discards the `Gram`-value of the children.
foldMapGram :: forall j l m. Functor j => (NodeG j l m -> m) -> Gram j l -> m
foldMapGram f = Newtype.unwrap <<< traverseGram (Const <<< f <<< mapNodeG_g Newtype.unwrap)

-- | Traverse a function `f` over the ExprLabels of a `Gram`, taking into account
-- | `Node` structure. This is the most general function over `Gram`, which
-- | `mapGram`, `foldMapGram`, etc are built out of.
-- |
-- | Observe that `f`'s type specifies that `f` assumes that the children of
-- | each `Node` it traverses has already had its children traversed. In this
-- | way, you don't have to manually call `traverseGram` on the children. If you
-- | want the traversal over the children to use data computed while traversing
-- | the parent, then `m` should implement `MonadReader r` where `r` is whatever
-- | data the children can use, and `f` should use `Reader.local` in order to
-- | provide that data. See (!TODO link to example here) for an example of this
-- | pattern.
traverseGram :: forall j l l' m. Functor j => Functor m => (NodeM j m l l' -> m (Node j l' l')) -> Gram j l -> m (Gram j l')
traverseGram f (Gram (l /\ j)) = Gram <$> f (l /\ (traverseGram f <$> j))

traverseGram_ :: forall j l m a. Functor j => Functor m => (NodeMG j m l a -> m a) -> Gram j l -> m a
traverseGram_ f (Gram (l /\ j)) = f (l /\ (traverseGram_ f <$> j))

logGramString :: forall j. Functor j => Traversable j => Gram j String -> Effect Unit
logGramString = traverseGram_ \(l /\ j) -> do
  log l 
  sequence_ j
-}

-- | Expr
type Expr = Gram Array

expr l kids = Gram (l /\ kids)

-- | MetaExpr
type MetaExpr l = Gram Array (Meta l)

-- | Tooth
type Tooth l = l /\ ZipList.Path (Expr l)

foldMapTooth :: forall l m. Monoid m => (l -> m) -> Tooth l -> m
foldMapTooth f (l /\ p) = f l <> foldMap (foldMap f) p

foldlTooth :: forall l a b. (b -> a -> b) -> b -> Tooth a -> b
foldlTooth f b (l /\ p) = ZipList.foldlAround (foldl f) b (flip f l) p

foldrTooth :: forall l a b. (a -> b -> b) -> b -> Tooth a -> b
foldrTooth f b (l /\ p) = ZipList.foldrAround (flip (foldr f)) b (f l) p

traverseTooth :: forall l l' m. Applicative m => (l -> m l') -> Tooth l -> m (Tooth l')
traverseTooth f (l /\ p) = Tuple <$> f l <*> traverse (traverse f) p

unTooth (l /\ p) g = expr l (Array.fromFoldable (ZipList.unpathAround g p))

showTooth (l /\ p) = show l <> " " <> intercalate " " (ZipList.unpathAround "{}" (show <$> p))

newtype Path (dir :: Symbol) l = Path (List (Tooth l))
derive instance Newtype (Path dir l) _
derive newtype instance Show l => Show (Path dir l)
derive newtype instance Eq l => Eq (Path dir l)
derive newtype instance (Eq l, Ord l) => Ord (Path dir l)

-- For getting the direction of a path as a value, without having to keep a
-- value stored in the path that is maintained to correspond to the type's dir
-- annotation
class ReflectPathDir (dir :: Symbol) where reflectPathDir :: forall l. Path dir l -> Dir.Dir
instance ReflectPathDir Dir.Down where reflectPathDir _ = Dir.Down
instance ReflectPathDir Dir.Up where reflectPathDir _ = Dir.Up

instance ReflectPathDir dir => Semigroup (Path dir l) where
  append = ?a

stepPath :: forall dir l. Tooth l -> Path dir l -> Path dir l
stepPath th (Path ths) = Path (th : ths)

unstepPath :: forall dir l. Path dir l -> Maybe (Tooth l /\ Path dir l)
unstepPath (Path Nil) = Nothing
unstepPath (Path (th : ths)) = Just (th /\ Path ths)

-- traverseDownPath :: forall dir l l' m. Applicative m => (Path1NodeM m l l' -> m (Path1Node l' l')) -> Path dir l -> m (Path dir l')
-- traverseDownPath f = Newtype.unwrap >>> case _ of 
--   Nothing -> Newtype.wrap <$> pure Nothing
--   Just p -> Newtype.wrap <$> (Just <$> traverseGram f p)

-- -- | Basically, traverse the path in reverse. The implementation uses
-- -- | tail-recursion to be efficient.
-- traverseUpPath :: forall dir l l' m. Applicative m => (Path1NodeM m l l' -> m (Path1Node l' l')) -> Path dir l -> m (Path dir l')
-- traverseUpPath f = map Path <<< go Nothing <<< Newtype.unwrap
--   where
--   go :: Maybe (m (Path1 l')) -> Maybe (Path1 l) -> m (Maybe (Path1 l'))
--   go m_pBelow Nothing = sequence m_pBelow
--   go m_pBelow (Just p1Above) = go (Just $ Gram <$> f (gramExprLabel p1Above /\ m_pBelow)) (gramJoint p1Above)

-- if = down, then p1 goes below
-- if = up, then p1 goes above
appendPath :: forall dir l. Path dir l -> Path dir l -> Path dir l
appendPath path1 (Path p2) = case p2 of
  Nil -> path1
  th : ths -> stepPath th (appendPath path1 (Path ths))

reversePath :: forall dir dir' l. Dir.Rev dir dir' => Path dir l -> Path dir' l
reversePath (Path ths) = Path (List.reverse ths)

-- | Zipper
type Zipper l = {path :: Path Dir.Up l, expr :: Expr l}

zipUp :: forall l. Zipper l -> Maybe (Tooth l /\ Zipper l)
zipUp zipper = case zipper.path of
  Path Nil -> Nothing
  Path (th : ths) -> Just $ th /\ {path: Path ths, expr: unTooth th zipper.expr}

-- | Only zip down the kids in the tooth (not the interior of the tooth).
zipDownsTooth :: forall l. GramExprLabel l => Zipper l -> Tooth l -> ZipList.Path (Zipper l)
zipDownsTooth zipper (_ /\ kidsPath) = do
  let ix = ZipList.leftLength kidsPath
  let zs = zipDowns zipper
  case ZipList.zipAt ix (List.fromFoldable zs) of
    Nothing -> unsafeCrashWith "[zipDownsTooth] bad index"
    Just (zipsPath /\ _kidZip) -> zipsPath

zipDowns :: forall l. Zipper l -> Array (Zipper l)
zipDowns {path, expr: Gram (l /\ kids0)} = 
  case Array.uncons kids0 of
    Nothing -> []
    Just {head: kid0, tail: kids1} ->
      go
        []
        (l /\ ZipList.Path {left: mempty, right: List.fromFoldable kids1})
        kid0
  where
  go :: Array (Zipper l) -> Tooth l -> Expr l -> Array (Zipper l)
  go zippers th@(_ /\ ZipList.Path {right: Nil}) kid =
    Array.reverse $ Array.cons {path: stepPath th path, expr: kid} zippers
  go zippers th@(l' /\ ZipList.Path {left, right: Cons kid' kids'}) kid =
    go
      (Array.cons {path: stepPath th path, expr: kid} zippers)
      (l' /\ ZipList.Path {left: RevList.snoc left kid, right: kids'})
      kid'

zipLeft :: forall l. Zipper l -> Maybe (Zipper l)
zipLeft zipper = case zipper.path of
  Path Nil -> Nothing
  Path ((l /\ kidsPath) : ths) -> do
    expr' /\ kidsPath' <- ZipList.zipLeft (zipper.expr /\ kidsPath)
    Just $ {path: Path ((l /\ kidsPath') : ths), expr: expr'}

zipRight :: forall l. Zipper l -> Maybe (Zipper l)
zipRight zipper = case zipper.path of
  Path Nil -> Nothing
  -- Path (Just (Gram ((l /\ kidsPath) /\ path'))) -> do
  Path ((l /\ kidsPath) : ths) -> do
    expr' /\ kidsPath' <- ZipList.zipRight (zipper.expr /\ kidsPath)
    Just $ {path: Path ((l /\ kidsPath') : ths), expr: expr'}

-- | Zipperp is the first derivative of a zipper (a zipper selection)
type Zipperp l = 
  { path :: Path Dir.Up l
  , selection :: forall dir. Path dir l
  , expr :: Expr l
  }

-- | Change
type Change l = Expr (ChangeLabel l)
data ChangeLabel l
  = Plus (Tooth l) {-one kid - whatever fits inside the tooth-}
  | Minus (Tooth l) {-one kid - whatever fits inside the tooth-}
  | Expr l {-same number of kids that l has-}
  | Replace (Expr l) (Expr l) {-zero kids?-}

derive instance Generic (ChangeLabel l) _
derive instance Eq l => Eq (ChangeLabel l)
derive instance Ord l => Ord (ChangeLabel l)

instance Show l => Show (ChangeLabel l) where
  show (Plus th) = "(+ " <> showTooth th <> ")"
  show (Minus th) = "(- " <> showTooth th <> ")"
  show (Expr e) = show e
  show (Replace e1 e2) = "(" <> show e1 <> "~~> " <> show e2 <> ")"

derive instance Functor ChangeLabel

instance Foldable ChangeLabel where
  foldMap f = case _ of
    Plus th -> foldMapTooth f th
    Minus th -> foldMapTooth f th
    Expr l -> f l
    Replace e1 e2 -> foldMap f e1 <> foldMap f e2
  foldl f b = case _ of
    Plus th -> foldlTooth f b th
    Minus th -> foldlTooth f b th
    Expr l -> f b l
    Replace e1 e2 -> foldl f (foldl f b e1) e2
  foldr f b = case _ of 
    Plus th -> foldrTooth f b th
    Minus th -> foldrTooth f b th
    Expr l -> f l b
    Replace e1 e2 -> foldr f (foldr f b e2) e1

instance Traversable ChangeLabel where
  traverse f = case _ of
    Plus th -> Plus <$> traverseTooth f th
    Minus th -> Minus <$> traverseTooth f th
    Expr l -> Expr <$> f l
    Replace e1 e2 -> Replace <$> traverse f e1 <*> traverse f e2
  sequence fa = sequenceDefault fa

type MetaChange l = Change (Meta l)

plusChange :: forall l. Tooth l -> Change l -> Change l
plusChange th g = Gram (Plus th /\ [g])

minusChange :: forall l. Tooth l -> Change l -> Change l
minusChange th g = Gram (Minus th /\ [g])

exprChange :: forall l. l -> Array (Change l) -> Change l
exprChange l g = Gram (Expr l /\ g)

replaceChange :: forall l. Expr l -> Expr l -> Change l
replaceChange e1 e2 = Gram (Replace e1 e2 /\ [])

matchChangeNode :: forall l g a.
  NodeG Array (ChangeLabel l) g ->
  { plus :: Tooth l -> g -> a
  , minus :: Tooth l -> g -> a
  , expr :: l -> Array g -> a
  , replace :: Expr l -> Expr l -> a
  } -> a
matchChangeNode = flip \f -> case _ of
  (Plus th /\ [kid]) -> f.plus th kid
  (Minus th /\ [kid]) -> f.minus th kid
  (Expr l /\ kids) -> f.expr l kids
  (Replace e1 e2 /\ []) -> f.replace e1 e2
  g -> unsafeCrashWith $ "invalid change: " <> showNodeUnit g

matchChange (Gram n) = matchChangeNode n

-- -- Name (placeholder)

-- newtype Name = Name String

-- ex_ex1 :: Expr String
-- ex_ex1 = expr "A" [ expr "B" [], expr "C" [] ]

-- derive instance Eq l => Eq (Expr l)
-- derive instance Ord l => Ord (Expr l)
-- derive instance Generic Name _
-- derive newtype instance Eq Name
-- derive newtype instance Ord Name
-- instance Show Name where show (Name str) = str
-- -- instance (Functor m, Plus.Plus m, Applicative m) => Unify m Name where unify x y = genericUnify x y